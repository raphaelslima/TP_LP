

Definições:

- Apresentem o relatório com gráficos e tabelas;
- Escrevam no relatório a percepção de vocês em implementar os códigos;

- Vocês devem implementar uma versão sequencial - sem paralelismo - e uma paralela em OpenMP - ambas utilizando somente aritmética de ponteiros - de:
  - Filtro de suavização -> cada elemento será substituído pela média dos seus vizinhos diretos;

- Não há necessidade de usar uma imagem real, simulem uma imagem criando matrizes aleatórias onde cada posição da matriz é um número entre 0 e 255;

- Vocês devem medir os tempos de execução de cada cenário e criar um relatório com as comparações dos tempos de execução com omp_get_wtime();
- Tamanhos das matrizes: 1000 x 1000, 5000 x 5000 e 10000 x 10000;

TAREFAS:
- Quantidade de Threads: 
1 (versão sequencial) (Maurício)
2 
4
8


  - Há benefício em usar o OpenMP?
  - Há vantagem em utilizar a aritmética de ponteiros em relação as implementações comuns?
  - A legibilidade é ruim?
  - Há facilidade de escrita? Em qual dos temas? (aritmética de ponteiros e OpenMP)
- Analisem o porquê da diferença dos tempos de execução.



/// código sequencial rascunho de uma matriz

#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

int main() {
    /*
    Inicializa a função para gerar números aleatórios, a time(0) retorna um núemro em segundos desde 1 de jan de 1970 
    e a srand() gera uma sequência de números aleatórios , como o parâmetro sempre mudará graças ao time(0) a sequência sempre 
    será diferente em cada execução.
    */
    srand(time(0)); 

    // Aloca matriz de tamanho 10 usando ponteiros
    int* matriz = new int[10]; 

    // Preenche as matrizes com números aleatórios entre 0 e 255
    for (int i = 0; i < 10; i++) {
        *(matriz + i) = rand() % 256;
    }

    // Exibe os valores armazenados na matriz
    cout << "Matriz original:" << endl;
    for (int i = 0; i < 10; i++) {
        cout << *(matriz + i) << " ";
    }
    cout << endl;

    // Criar uma nova matriz para armazenar os novos valores após a operação.
    int* nova_matriz = new int[10];

    /* Substituir os elementos pela média dos vizinhos, se for a primeira posição pega o próprio valor e o vizinho a dirita, 
    se for a primeira posição pega o próprio valor e o vizinho a esquerda 
    e se for um elemento que não está nas extremidades pega o vizinho da esquerda e o da direita.
    */
    for (int i = 0; i < 10; i++) {
        if (i == 0)
            *(nova_matriz + i) = (*(matriz + i) + *(matriz + i + 1)) / 2;
        else if (i == 9)
            *(nova_matriz + i) = (*(matriz + i) + *(matriz + i - 1)) / 2;
        else
            *(nova_matriz + i) = (*(matriz + i - 1) + *(matriz + i + 1)) / 2;
    }

    // Copia os valores da nova matriz para a matriz original
    for (int i = 0; i < 10; i++) {
        *(matriz + i) = *(nova_matriz + i);
    }

    // Exibe os valores após a substituição
    cout << "Matriz apos substituicao:" << endl;
    for (int i = 0; i < 10; i++) {
        cout << *(matriz + i) << " ";
    }
    cout << endl;

    // Libera a memória alocada
    delete[] matriz; 
    delete[] nova_matriz;
    return 0;
}
